### King of bots

基于Springboot + vue3开发的一个在线的双人贪吃蛇对游戏。

PK：匹配截面（微服务），实况直播（WebSocket），真人Pk（WebSocket)

对战列表：录像回放

排行榜：bot列表

我的bot：管理我的bot

登录注册：

### 前端

使用Vue3脚手架，BootStrap组件库

游戏地图使用canvas画布进行绘制

使用Ajax请求后端接口

### 后端

后端基于SpringBoot框架实现

使用MyBatisPlus实现Mapper层

使用Jwt实现跨域访问，解决信息丢失问题

使用vue3-ace-editor设置前端代码编辑

使用SpringCloud实现匹配系统，BOt代码执行系统微服务

使用RestTemplate进行线程之间的通信，对接微服务系统

##### 登录持久化

当我们的用户重定向到登陆页面的时候,我们可以事先判断一下他们有没有将token存在本地 如果存在本地就把token取出来,验证一下是否过期 如果没有过期，用户就不需要重新登陆了,可以直接跳转到首页 刷新之后其实是一个未登录状态,自动先跳到我们的登录页面 先从本地把我们的token取出来,发现token存在把token，更新到我们的内存当中,然后再从云端请求下这个用户的信息 如果可以请求的信息表示我们的token，是有效的，，表示用户是登录的，我们就可以跳转到首页

##### 匹配系统原理剖析

都点击匹配向服务器发出请求匹配系统不会立即返回结果，一般会匹配个几秒 整个游戏是异步的过程，计算量比较大的过程，所以我们就另外写一个进程 后端接收的请求，会将用户的请求，发送给我们的匹配系统，匹配系统维护了一堆用户的集合 匹配系统里有很多很多的用户，将当前用户中战斗力最相近的几个人匹配到一起 然后将我们的匹配结果返回给网站后端返回给serverSpringBoot 返回之后我们的后端就会把结果返回给前端、我们在前端就可以看到匹配的对手是谁 整个匹配的过程其实是一个异步的过程、匹配的过程会经过一段比较长的时间 什么时候有匹配结果我们是未知的

##### 在云端维护游戏的整个流程

先生成一个地图，将两个地图传给两个客户端，传完之后等待用户输入 waiting、我们可以从代码端获取下一步操作也可以客户端返还 代码端要用微服务了，waiting可以写一个死循环每次循环前先sleep一秒钟 然后判断一下是否两条蛇的下一步操作都有了、如果有的话进行下一步 如果没有的话继续等待、当然我们可以设定一个最大时间最大5s 如果5s之内没有得到下一步操作的话、我们就判断没有输入操作的蛇输 如果超时就判断输赢、如果获得输入写一个judging程序、判断是否合法和撞墙、这个游戏的逻辑

##### WebSocket协议原理剖析

基本原理就是、每一个连接我们都会在后端维护起来，我们会把前端建立的每一个websocket连接在后端维护起来， 比如我们的Clint1连接到我们的服务器、其实一个连接就是一个类 其实就是一个websocketserver类，每来一个连接，其实就是new一个这个类的实例 先创建这个类，我们每次来一个连接的时候本质上就是new一个这个类的实例 每一个连接都是这个类的一个实列来维护的、所有和这个连接相关的信息 都会存到这个类里面、如果是每一个连接自己独有的信息、比如说维护这个连接对应的用户是谁 那可以存成私有变量、如果是维护所有连接的公共信息 比如我们想去维护一下当前哪些用户建立的连接、那么可以存成一个静态变量 WebSocket就是一个多线程、每来一个连接就会开一个新的线程来维护它这个websocket就是一个类 每来一个连接就会开一个线程创建一个类，去维护这个连接流程 用户开始匹配的时候向后端发送一个请求、就会在后端websocket里new一个新的类开一个线程 来维护这个链接那么接收到这个请求之后、我们会把我们的信息发送给我们的匹配系统 匹配系统是一个单独的额外的程序、匹配系统当接收到很多的用户之后随着时间的推移 出现两名玩家的战斗力比较接近匹配出来一局、匹配系统就会将信息返回给我们的后端服务器 也就是我们的websocket服务器、websocket服务器接受到这个信息之后就会将这个信息返回 给这局对战的两名玩家、根据两名玩家建立的链接返还到他们的前端的浏览器里面 同时在我们的服务器端创建一个游戏的过程、因为整个游戏的判断地图的生成都是在云端进行的 这就是websocket的基本原理

##### WebSocketServer

当我们建立链接的时候我们需要从token中读取当前的用户是谁， 有了id之后去插数据库去查id是谁，查数据库注入userMapper 静态变量相当于是所有实例的一个全局变量， 如果不加静态变量的话那就是所有的实列所有独有一份，哈希表是对所有的实例都可见 每一个实例都要访问同一个哈希表，不加static 相当于局部变量 websocketserver，并不是一个标准的spring里的组件，注入的时候跟controller是有所区别的 静态变量访问的时候需要用类名访问